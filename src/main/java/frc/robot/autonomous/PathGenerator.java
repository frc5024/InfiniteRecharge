package frc.robot.autonomous;

import java.util.Arrays;
import java.util.List;

import edu.wpi.first.wpilibj.controller.PIDController;
import edu.wpi.first.wpilibj.controller.RamseteController;
import edu.wpi.first.wpilibj.controller.SimpleMotorFeedforward;
import edu.wpi.first.wpilibj.geometry.Pose2d;
import edu.wpi.first.wpilibj.geometry.Rotation2d;
import edu.wpi.first.wpilibj.geometry.Translation2d;
import edu.wpi.first.wpilibj.trajectory.Trajectory;
import edu.wpi.first.wpilibj.trajectory.TrajectoryConfig;
import edu.wpi.first.wpilibj.trajectory.TrajectoryGenerator;
import edu.wpi.first.wpilibj.trajectory.constraint.DifferentialDriveVoltageConstraint;
import edu.wpi.first.wpilibj2.command.RamseteCommand;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import frc.robot.RobotConstants;
import frc.robot.subsystems.DriveTrain;

public class PathGenerator {

	public static class SpeedConstraint {
		public double maxSpeedPercent;
		public double maxAccelPercent;

		public SpeedConstraint(double maxSpeedPercent, double maxAccelPercent) {
			this.maxAccelPercent = maxAccelPercent;
			this.maxSpeedPercent = maxSpeedPercent;

		}
	}

	public static class EasyTrajectory {

		/* Trajectory points */
		private Pose2d[] points;
		private Translation2d inner1, inner2;

		/**
		 * Trajectory type
		 * 
		 * From WPI:
		 * 
		 * - Hermite clamped cubic: This is the recommended option for most users.
		 * Generation of trajectories using these splines involves specifying the (x, y)
		 * coordinates of all points, and the headings at the start and end waypoints.
		 * The headings at the interior waypoints are automatically determined to ensure
		 * continuous curvature (rate of change of the heading) throughout.
		 * 
		 * - Hermite quintic: This is a more advanced option which requires the user to
		 * specify (x, y) coordinates and headings for all waypoints. This should be
		 * used if you are unhappy with the trajectories that are being generated by the
		 * clamped cubic splines or if you want finer control of headings at the
		 * interior points.
		 * 
		 */
		public boolean isQuintic;

		/**
		 * Create a trajectory from a start and end position
		 * 
		 * @param start Start pose
		 * @param end   End pose
		 */
		public EasyTrajectory(Pose2d start, Pose2d end) {
			this.points = new Pose2d[] { start, end };
			this.isQuintic = true;
		}

		/**
		 * Create a trajectory from a list of points
		 * 
		 * @param points Array of poses
		 */
		public EasyTrajectory(Pose2d[] points) {

			// Ensure there are enough points
			assert points.length >= 2;

			this.points = points;
			this.isQuintic = true;
		}

		/**
		 * Create a cubic spline trajectory from start, end, and s-curve points
		 * 
		 * @param start Start pose
		 * @param a     First interior translation
		 * @param b     Second interior translation
		 * @param end   End pose
		 */
		public EasyTrajectory(Pose2d start, Translation2d a, Translation2d b, Pose2d end) {
			this.points = new Pose2d[] { start, end };
			this.inner1 = a;
			this.inner2 = b;
			this.isQuintic = false;
		}

		/**
		 * Get all defined absolute points. If this is a cubic spline, they will be the
		 * start and end poses
		 * 
		 * @return All Poses
		 */
		public List<Pose2d> getABSPoints() {
			return Arrays.asList(points);
		}

		/**
		 * Get interior points. This will be null if not cubic
		 * 
		 * @return Interior points
		 */
		public List<Translation2d> getInteriorPoints() {
			return List.of(this.inner1, this.inner2);
		}
	}

	public static SequentialCommandGroup generate(EasyTrajectory t, SpeedConstraint constraint) {

		SimpleMotorFeedforward feedforward = new SimpleMotorFeedforward(RobotConstants.ControlGains.ksVolts,
				RobotConstants.ControlGains.kvVoltsSecondsPerMeter,
				RobotConstants.ControlGains.kaVoltsSecondsSquaredPerMeter);

		// Creates constrains for motor controller voltage
		DifferentialDriveVoltageConstraint voltageConstraint = new DifferentialDriveVoltageConstraint(feedforward,
				RobotConstants.ControlGains.kDriveKinematics, 10);

		// Creates configuration for trajectory
		TrajectoryConfig config = new TrajectoryConfig(
				RobotConstants.ControlGains.kMaxSpeedMetersPerSecond * constraint.maxSpeedPercent,
				RobotConstants.ControlGains.kMaxAccelerationMetersPerSecondSquared * constraint.maxAccelPercent)
						.setKinematics(RobotConstants.ControlGains.kDriveKinematics).addConstraint(voltageConstraint);

		// Creates a trajectory to follow
		// Trajectory trajectory = TrajectoryGenerator.generateTrajectory(new Pose2d(0,
		// 0, new Rotation2d(0)),
		// // Pass through these two interior waypoints, making an 's' curve path
		// List.of(new Translation2d(1, 0), new Translation2d(2, 0)),
		// // End 3 meters straight ahead of where we started, facing forward
		// new Pose2d(3, 0, new Rotation2d(0)), config);
		// Trajectory trajectory = TrajectoryGenerator.generateTrajectory(List.of(start,
		// end), config);

		// Determine trajectory type
		Trajectory trajectory;

		if (t.isQuintic) {
			// Configure Quintic spline
			trajectory = TrajectoryGenerator.generateTrajectory(t.getABSPoints(), config);
		} else {
			// Configure cubic spline
			trajectory = TrajectoryGenerator.generateTrajectory(t.getABSPoints().get(0), t.getInteriorPoints(),
					t.getABSPoints().get(0), config);
		}

		// returns a new command that follows the trajectory
		return new RamseteCommand(trajectory, DriveTrain.getInstance()::getPosition,
				new RamseteController(RobotConstants.ControlGains.kRamseteB, RobotConstants.ControlGains.kRamseteZeta),
				feedforward, RobotConstants.ControlGains.kDriveKinematics, DriveTrain.getInstance()::getWheelSpeeds,
				new PIDController(RobotConstants.ControlGains.kPDriveVel, RobotConstants.ControlGains.kIDriveVel,
						RobotConstants.ControlGains.kDDriveVel),
				new PIDController(RobotConstants.ControlGains.kPDriveVel, RobotConstants.ControlGains.kIDriveVel,
						RobotConstants.ControlGains.kDDriveVel),
				DriveTrain.getInstance()::setVoltage, DriveTrain.getInstance()).andThen(DriveTrain.getInstance()::stop);

	}

}